/* tslint:disable */
/* eslint-disable */
/**
 * Stripe Payment Sample
 * this is an stripe payment example
 *
 * The version of the OpenAPI document: 1.0
 * Contact: dev@mattiamueggler.ch
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface MainCreditCard
 */
export interface MainCreditCard {
    /**
     * 
     * @type {string}
     * @memberof MainCreditCard
     */
    'cardnumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof MainCreditCard
     */
    'cvc'?: string;
    /**
     * 
     * @type {number}
     * @memberof MainCreditCard
     */
    'expire_month'?: number;
    /**
     * 
     * @type {number}
     * @memberof MainCreditCard
     */
    'expire_year'?: number;
}
/**
 * 
 * @export
 * @interface MainCustomer
 */
export interface MainCustomer {
    /**
     * 
     * @type {string}
     * @memberof MainCustomer
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof MainCustomer
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof MainCustomer
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MainCustomer
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof MainCustomer
     */
    'firstname'?: string;
    /**
     * 
     * @type {string}
     * @memberof MainCustomer
     */
    'lastname'?: string;
    /**
     * 
     * @type {string}
     * @memberof MainCustomer
     */
    'post_cod'?: string;
    /**
     * 
     * @type {string}
     * @memberof MainCustomer
     */
    'province'?: string;
    /**
     * 
     * @type {string}
     * @memberof MainCustomer
     */
    'street'?: string;
    /**
     * 
     * @type {string}
     * @memberof MainCustomer
     */
    'street_nr'?: string;
}
/**
 * 
 * @export
 * @interface MainError
 */
export interface MainError {
    /**
     * 
     * @type {string}
     * @memberof MainError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface MainPaymentRequest
 */
export interface MainPaymentRequest {
    /**
     * 
     * @type {number}
     * @memberof MainPaymentRequest
     */
    'amount'?: number;
    /**
     * 
     * @type {MainCreditCard}
     * @memberof MainPaymentRequest
     */
    'credit_card'?: MainCreditCard;
    /**
     * 
     * @type {string}
     * @memberof MainPaymentRequest
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof MainPaymentRequest
     */
    'product_id'?: string;
}
/**
 * 
 * @export
 * @interface MainPaymentRequestWithCustomer
 */
export interface MainPaymentRequestWithCustomer {
    /**
     * 
     * @type {number}
     * @memberof MainPaymentRequestWithCustomer
     */
    'amount'?: number;
    /**
     * 
     * @type {MainCreditCard}
     * @memberof MainPaymentRequestWithCustomer
     */
    'credit_card'?: MainCreditCard;
    /**
     * 
     * @type {string}
     * @memberof MainPaymentRequestWithCustomer
     */
    'currency'?: string;
    /**
     * 
     * @type {MainCustomer}
     * @memberof MainPaymentRequestWithCustomer
     */
    'customer'?: MainCustomer;
    /**
     * 
     * @type {string}
     * @memberof MainPaymentRequestWithCustomer
     */
    'product_id'?: string;
}
/**
 * 
 * @export
 * @interface MainSuccessPayment
 */
export interface MainSuccessPayment {
    /**
     * 
     * @type {string}
     * @memberof MainSuccessPayment
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const StripeCurrency = {
    CurrencyAED: 'aed',
    CurrencyAFN: 'afn',
    CurrencyALL: 'all',
    CurrencyAMD: 'amd',
    CurrencyANG: 'ang',
    CurrencyAOA: 'aoa',
    CurrencyARS: 'ars',
    CurrencyAUD: 'aud',
    CurrencyAWG: 'awg',
    CurrencyAZN: 'azn',
    CurrencyBAM: 'bam',
    CurrencyBBD: 'bbd',
    CurrencyBDT: 'bdt',
    CurrencyBGN: 'bgn',
    CurrencyBIF: 'bif',
    CurrencyBMD: 'bmd',
    CurrencyBND: 'bnd',
    CurrencyBOB: 'bob',
    CurrencyBRL: 'brl',
    CurrencyBSD: 'bsd',
    CurrencyBWP: 'bwp',
    CurrencyBZD: 'bzd',
    CurrencyCAD: 'cad',
    CurrencyCDF: 'cdf',
    CurrencyCHF: 'chf',
    CurrencyCLP: 'clp',
    CurrencyCNY: 'cny',
    CurrencyCOP: 'cop',
    CurrencyCRC: 'crc',
    CurrencyCVE: 'cve',
    CurrencyCZK: 'czk',
    CurrencyDJF: 'djf',
    CurrencyDKK: 'dkk',
    CurrencyDOP: 'dop',
    CurrencyDZD: 'dzd',
    CurrencyEEK: 'eek',
    CurrencyEGP: 'egp',
    CurrencyETB: 'etb',
    CurrencyEUR: 'eur',
    CurrencyFJD: 'fjd',
    CurrencyFKP: 'fkp',
    CurrencyGBP: 'gbp',
    CurrencyGEL: 'gel',
    CurrencyGIP: 'gip',
    CurrencyGMD: 'gmd',
    CurrencyGNF: 'gnf',
    CurrencyGTQ: 'gtq',
    CurrencyGYD: 'gyd',
    CurrencyHKD: 'hkd',
    CurrencyHNL: 'hnl',
    CurrencyHRK: 'hrk',
    CurrencyHTG: 'htg',
    CurrencyHUF: 'huf',
    CurrencyIDR: 'idr',
    CurrencyILS: 'ils',
    CurrencyINR: 'inr',
    CurrencyISK: 'isk',
    CurrencyJMD: 'jmd',
    CurrencyJPY: 'jpy',
    CurrencyKES: 'kes',
    CurrencyKGS: 'kgs',
    CurrencyKHR: 'khr',
    CurrencyKMF: 'kmf',
    CurrencyKRW: 'krw',
    CurrencyKYD: 'kyd',
    CurrencyKZT: 'kzt',
    CurrencyLAK: 'lak',
    CurrencyLBP: 'lbp',
    CurrencyLKR: 'lkr',
    CurrencyLRD: 'lrd',
    CurrencyLSL: 'lsl',
    CurrencyLTL: 'ltl',
    CurrencyLVL: 'lvl',
    CurrencyMAD: 'mad',
    CurrencyMDL: 'mdl',
    CurrencyMGA: 'mga',
    CurrencyMKD: 'mkd',
    CurrencyMNT: 'mnt',
    CurrencyMOP: 'mop',
    CurrencyMRO: 'mro',
    CurrencyMUR: 'mur',
    CurrencyMVR: 'mvr',
    CurrencyMWK: 'mwk',
    CurrencyMXN: 'mxn',
    CurrencyMYR: 'myr',
    CurrencyMZN: 'mzn',
    CurrencyNAD: 'nad',
    CurrencyNGN: 'ngn',
    CurrencyNIO: 'nio',
    CurrencyNOK: 'nok',
    CurrencyNPR: 'npr',
    CurrencyNZD: 'nzd',
    CurrencyPAB: 'pab',
    CurrencyPEN: 'pen',
    CurrencyPGK: 'pgk',
    CurrencyPHP: 'php',
    CurrencyPKR: 'pkr',
    CurrencyPLN: 'pln',
    CurrencyPYG: 'pyg',
    CurrencyQAR: 'qar',
    CurrencyRON: 'ron',
    CurrencyRSD: 'rsd',
    CurrencyRUB: 'rub',
    CurrencyRWF: 'rwf',
    CurrencySAR: 'sar',
    CurrencySBD: 'sbd',
    CurrencySCR: 'scr',
    CurrencySEK: 'sek',
    CurrencySGD: 'sgd',
    CurrencySHP: 'shp',
    CurrencySLL: 'sll',
    CurrencySOS: 'sos',
    CurrencySRD: 'srd',
    CurrencySTD: 'std',
    CurrencySVC: 'svc',
    CurrencySZL: 'szl',
    CurrencyTHB: 'thb',
    CurrencyTJS: 'tjs',
    CurrencyTOP: 'top',
    CurrencyTRY: 'try',
    CurrencyTTD: 'ttd',
    CurrencyTWD: 'twd',
    CurrencyTZS: 'tzs',
    CurrencyUAH: 'uah',
    CurrencyUGX: 'ugx',
    CurrencyUSD: 'usd',
    CurrencyUYU: 'uyu',
    CurrencyUZS: 'uzs',
    CurrencyVEF: 'vef',
    CurrencyVND: 'vnd',
    CurrencyVUV: 'vuv',
    CurrencyWST: 'wst',
    CurrencyXAF: 'xaf',
    CurrencyXCD: 'xcd',
    CurrencyXOF: 'xof',
    CurrencyXPF: 'xpf',
    CurrencyYER: 'yer',
    CurrencyZAR: 'zar',
    CurrencyZMW: 'zmw'
} as const;

export type StripeCurrency = typeof StripeCurrency[keyof typeof StripeCurrency];


/**
 * 
 * @export
 * @interface StripePrice
 */
export interface StripePrice {
    /**
     * Whether the price can be used for new purchases.
     * @type {boolean}
     * @memberof StripePrice
     */
    'active'?: boolean;
    /**
     * Describes how to compute the price per period. Either `per_unit` or `tiered`. `per_unit` indicates that the fixed amount (specified in `unit_amount` or `unit_amount_decimal`) will be charged per unit in `quantity` (for prices with `usage_type=licensed`), or per unit of total usage (for prices with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as defined using the `tiers` and `tiers_mode` attributes.
     * @type {StripePriceBillingScheme}
     * @memberof StripePrice
     */
    'billing_scheme'?: StripePriceBillingScheme;
    /**
     * Time at which the object was created. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof StripePrice
     */
    'created'?: number;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @type {StripeCurrency}
     * @memberof StripePrice
     */
    'currency'?: StripeCurrency;
    /**
     * Prices defined in each available currency option. Each key must be a three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html) and a [supported currency](https://stripe.com/docs/currencies).
     * @type {{ [key: string]: StripePriceCurrencyOptions; }}
     * @memberof StripePrice
     */
    'currency_options'?: { [key: string]: StripePriceCurrencyOptions; };
    /**
     * 
     * @type {StripePriceCustomUnitAmount}
     * @memberof StripePrice
     */
    'custom_unit_amount'?: StripePriceCustomUnitAmount;
    /**
     * 
     * @type {boolean}
     * @memberof StripePrice
     */
    'deleted'?: boolean;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof StripePrice
     */
    'id'?: string;
    /**
     * Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
     * @type {boolean}
     * @memberof StripePrice
     */
    'livemode'?: boolean;
    /**
     * A lookup key used to retrieve prices dynamically from a static string. This may be up to 200 characters.
     * @type {string}
     * @memberof StripePrice
     */
    'lookup_key'?: string;
    /**
     * Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
     * @type {{ [key: string]: string; }}
     * @memberof StripePrice
     */
    'metadata'?: { [key: string]: string; };
    /**
     * A brief description of the price, hidden from customers.
     * @type {string}
     * @memberof StripePrice
     */
    'nickname'?: string;
    /**
     * String representing the object\'s type. Objects of the same type share the same value.
     * @type {string}
     * @memberof StripePrice
     */
    'object'?: string;
    /**
     * 
     * @type {StripePriceProduct}
     * @memberof StripePrice
     */
    'product'?: StripePriceProduct;
    /**
     * 
     * @type {StripePriceRecurring}
     * @memberof StripePrice
     */
    'recurring'?: StripePriceRecurring;
    /**
     * Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it cannot be changed.
     * @type {StripePriceTaxBehavior}
     * @memberof StripePrice
     */
    'tax_behavior'?: StripePriceTaxBehavior;
    /**
     * Each element represents a pricing tier. This parameter requires `billing_scheme` to be set to `tiered`. See also the documentation for `billing_scheme`.
     * @type {Array<StripePriceTier>}
     * @memberof StripePrice
     */
    'tiers'?: Array<StripePriceTier>;
    /**
     * Defines if the tiering price should be `graduated` or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per unit price. In `graduated` tiering, pricing can change as the quantity grows.
     * @type {StripePriceTiersMode}
     * @memberof StripePrice
     */
    'tiers_mode'?: StripePriceTiersMode;
    /**
     * 
     * @type {StripePriceTransformQuantity}
     * @memberof StripePrice
     */
    'transform_quantity'?: StripePriceTransformQuantity;
    /**
     * One of `one_time` or `recurring` depending on whether the price is for a one-time purchase or a recurring (subscription) purchase.
     * @type {StripePriceType}
     * @memberof StripePrice
     */
    'type'?: StripePriceType;
    /**
     * The unit amount in %s to be charged, represented as a whole integer if possible. Only set if `billing_scheme=per_unit`.
     * @type {number}
     * @memberof StripePrice
     */
    'unit_amount'?: number;
    /**
     * The unit amount in %s to be charged, represented as a decimal string with at most 12 decimal places. Only set if `billing_scheme=per_unit`.
     * @type {string}
     * @memberof StripePrice
     */
    'unit_amount_decimal'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const StripePriceBillingScheme = {
    PriceBillingSchemePerUnit: 'per_unit',
    PriceBillingSchemeTiered: 'tiered'
} as const;

export type StripePriceBillingScheme = typeof StripePriceBillingScheme[keyof typeof StripePriceBillingScheme];


/**
 * 
 * @export
 * @interface StripePriceCurrencyOptions
 */
export interface StripePriceCurrencyOptions {
    /**
     * 
     * @type {StripePriceCurrencyOptionsCustomUnitAmount}
     * @memberof StripePriceCurrencyOptions
     */
    'custom_unit_amount'?: StripePriceCurrencyOptionsCustomUnitAmount;
    /**
     * Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it cannot be changed.
     * @type {StripePriceCurrencyOptionsTaxBehavior}
     * @memberof StripePriceCurrencyOptions
     */
    'tax_behavior'?: StripePriceCurrencyOptionsTaxBehavior;
    /**
     * Each element represents a pricing tier. This parameter requires `billing_scheme` to be set to `tiered`. See also the documentation for `billing_scheme`.
     * @type {Array<StripePriceCurrencyOptionsTier>}
     * @memberof StripePriceCurrencyOptions
     */
    'tiers'?: Array<StripePriceCurrencyOptionsTier>;
    /**
     * The unit amount in %s to be charged, represented as a whole integer if possible. Only set if `billing_scheme=per_unit`.
     * @type {number}
     * @memberof StripePriceCurrencyOptions
     */
    'unit_amount'?: number;
    /**
     * The unit amount in %s to be charged, represented as a decimal string with at most 12 decimal places. Only set if `billing_scheme=per_unit`.
     * @type {string}
     * @memberof StripePriceCurrencyOptions
     */
    'unit_amount_decimal'?: string;
}
/**
 * When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.
 * @export
 * @interface StripePriceCurrencyOptionsCustomUnitAmount
 */
export interface StripePriceCurrencyOptionsCustomUnitAmount {
    /**
     * The maximum unit amount the customer can specify for this item.
     * @type {number}
     * @memberof StripePriceCurrencyOptionsCustomUnitAmount
     */
    'maximum'?: number;
    /**
     * The minimum unit amount the customer can specify for this item. Must be at least the minimum charge amount.
     * @type {number}
     * @memberof StripePriceCurrencyOptionsCustomUnitAmount
     */
    'minimum'?: number;
    /**
     * The starting unit amount which can be updated by the customer.
     * @type {number}
     * @memberof StripePriceCurrencyOptionsCustomUnitAmount
     */
    'preset'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const StripePriceCurrencyOptionsTaxBehavior = {
    PriceCurrencyOptionsTaxBehaviorExclusive: 'exclusive',
    PriceCurrencyOptionsTaxBehaviorInclusive: 'inclusive',
    PriceCurrencyOptionsTaxBehaviorUnspecified: 'unspecified'
} as const;

export type StripePriceCurrencyOptionsTaxBehavior = typeof StripePriceCurrencyOptionsTaxBehavior[keyof typeof StripePriceCurrencyOptionsTaxBehavior];


/**
 * 
 * @export
 * @interface StripePriceCurrencyOptionsTier
 */
export interface StripePriceCurrencyOptionsTier {
    /**
     * Price for the entire tier.
     * @type {number}
     * @memberof StripePriceCurrencyOptionsTier
     */
    'flat_amount'?: number;
    /**
     * Same as `flat_amount`, but contains a decimal value with at most 12 decimal places.
     * @type {string}
     * @memberof StripePriceCurrencyOptionsTier
     */
    'flat_amount_decimal'?: string;
    /**
     * Per unit price for units relevant to the tier.
     * @type {number}
     * @memberof StripePriceCurrencyOptionsTier
     */
    'unit_amount'?: number;
    /**
     * Same as `unit_amount`, but contains a decimal value with at most 12 decimal places.
     * @type {string}
     * @memberof StripePriceCurrencyOptionsTier
     */
    'unit_amount_decimal'?: string;
    /**
     * Up to and including to this quantity will be contained in the tier.
     * @type {number}
     * @memberof StripePriceCurrencyOptionsTier
     */
    'up_to'?: number;
}
/**
 * When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.
 * @export
 * @interface StripePriceCustomUnitAmount
 */
export interface StripePriceCustomUnitAmount {
    /**
     * The maximum unit amount the customer can specify for this item.
     * @type {number}
     * @memberof StripePriceCustomUnitAmount
     */
    'maximum'?: number;
    /**
     * The minimum unit amount the customer can specify for this item. Must be at least the minimum charge amount.
     * @type {number}
     * @memberof StripePriceCustomUnitAmount
     */
    'minimum'?: number;
    /**
     * The starting unit amount which can be updated by the customer.
     * @type {number}
     * @memberof StripePriceCustomUnitAmount
     */
    'preset'?: number;
}
/**
 * The ID of the product this price is associated with.
 * @export
 * @interface StripePriceProduct
 */
export interface StripePriceProduct {
    /**
     * Whether the product is currently available for purchase.
     * @type {boolean}
     * @memberof StripePriceProduct
     */
    'active'?: boolean;
    /**
     * A list of up to 5 attributes that each SKU can provide values for (e.g., `[\"color\", \"size\"]`).
     * @type {Array<string>}
     * @memberof StripePriceProduct
     */
    'attributes'?: Array<string>;
    /**
     * A short one-line description of the product, meant to be displayable to the customer. Only applicable to products of `type=good`.
     * @type {string}
     * @memberof StripePriceProduct
     */
    'caption'?: string;
    /**
     * Time at which the object was created. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof StripePriceProduct
     */
    'created'?: number;
    /**
     * An array of connect application identifiers that cannot purchase this product. Only applicable to products of `type=good`.
     * @type {Array<string>}
     * @memberof StripePriceProduct
     */
    'deactivate_on'?: Array<string>;
    /**
     * 
     * @type {StripeProductDefaultPrice}
     * @memberof StripePriceProduct
     */
    'default_price'?: StripeProductDefaultPrice;
    /**
     * 
     * @type {boolean}
     * @memberof StripePriceProduct
     */
    'deleted'?: boolean;
    /**
     * The product\'s description, meant to be displayable to the customer. Use this field to optionally store a long form explanation of the product being sold for your own rendering purposes.
     * @type {string}
     * @memberof StripePriceProduct
     */
    'description'?: string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof StripePriceProduct
     */
    'id'?: string;
    /**
     * A list of up to 8 URLs of images for this product, meant to be displayable to the customer.
     * @type {Array<string>}
     * @memberof StripePriceProduct
     */
    'images'?: Array<string>;
    /**
     * Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
     * @type {boolean}
     * @memberof StripePriceProduct
     */
    'livemode'?: boolean;
    /**
     * Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
     * @type {{ [key: string]: string; }}
     * @memberof StripePriceProduct
     */
    'metadata'?: { [key: string]: string; };
    /**
     * The product\'s name, meant to be displayable to the customer.
     * @type {string}
     * @memberof StripePriceProduct
     */
    'name'?: string;
    /**
     * String representing the object\'s type. Objects of the same type share the same value.
     * @type {string}
     * @memberof StripePriceProduct
     */
    'object'?: string;
    /**
     * 
     * @type {StripeProductPackageDimensions}
     * @memberof StripePriceProduct
     */
    'package_dimensions'?: StripeProductPackageDimensions;
    /**
     * Whether this product is shipped (i.e., physical goods).
     * @type {boolean}
     * @memberof StripePriceProduct
     */
    'shippable'?: boolean;
    /**
     * Extra information about a product which will appear on your customer\'s credit card statement. In the case that multiple products are billed at once, the first statement descriptor will be used.
     * @type {string}
     * @memberof StripePriceProduct
     */
    'statement_descriptor'?: string;
    /**
     * 
     * @type {StripeProductTaxCode}
     * @memberof StripePriceProduct
     */
    'tax_code'?: StripeProductTaxCode;
    /**
     * The type of the product. The product is either of type `good`, which is eligible for use with Orders and SKUs, or `service`, which is eligible for use with Subscriptions and Plans.
     * @type {StripeProductType}
     * @memberof StripePriceProduct
     */
    'type'?: StripeProductType;
    /**
     * A label that represents units of this product. When set, this will be included in customers\' receipts, invoices, Checkout, and the customer portal.
     * @type {string}
     * @memberof StripePriceProduct
     */
    'unit_label'?: string;
    /**
     * Time at which the object was last updated. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof StripePriceProduct
     */
    'updated'?: number;
    /**
     * A URL of a publicly-accessible webpage for this product.
     * @type {string}
     * @memberof StripePriceProduct
     */
    'url'?: string;
}
/**
 * The recurring components of a price such as `interval` and `usage_type`.
 * @export
 * @interface StripePriceRecurring
 */
export interface StripePriceRecurring {
    /**
     * Specifies a usage aggregation strategy for prices of `usage_type=metered`. Allowed values are `sum` for summing up all usage during a period, `last_during_period` for using the last usage record reported within a period, `last_ever` for using the last usage record ever (across period bounds) or `max` which uses the usage record with the maximum reported usage during a period. Defaults to `sum`.
     * @type {StripePriceRecurringAggregateUsage}
     * @memberof StripePriceRecurring
     */
    'aggregate_usage'?: StripePriceRecurringAggregateUsage;
    /**
     * The frequency at which a subscription is billed. One of `day`, `week`, `month` or `year`.
     * @type {StripePriceRecurringInterval}
     * @memberof StripePriceRecurring
     */
    'interval'?: StripePriceRecurringInterval;
    /**
     * The number of intervals (specified in the `interval` attribute) between subscription billings. For example, `interval=month` and `interval_count=3` bills every 3 months.
     * @type {number}
     * @memberof StripePriceRecurring
     */
    'interval_count'?: number;
    /**
     * Default number of trial days when subscribing a customer to this price using [`trial_from_plan=true`](https://stripe.com/docs/api#create_subscription-trial_from_plan).
     * @type {number}
     * @memberof StripePriceRecurring
     */
    'trial_period_days'?: number;
    /**
     * Configures how the quantity per period should be determined. Can be either `metered` or `licensed`. `licensed` automatically bills the `quantity` set when adding it to a subscription. `metered` aggregates the total usage based on usage records. Defaults to `licensed`.
     * @type {StripePriceRecurringUsageType}
     * @memberof StripePriceRecurring
     */
    'usage_type'?: StripePriceRecurringUsageType;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const StripePriceRecurringAggregateUsage = {
    PriceRecurringAggregateUsageLastDuringPeriod: 'last_during_period',
    PriceRecurringAggregateUsageLastEver: 'last_ever',
    PriceRecurringAggregateUsageMax: 'max',
    PriceRecurringAggregateUsageSum: 'sum'
} as const;

export type StripePriceRecurringAggregateUsage = typeof StripePriceRecurringAggregateUsage[keyof typeof StripePriceRecurringAggregateUsage];


/**
 * 
 * @export
 * @enum {string}
 */

export const StripePriceRecurringInterval = {
    PriceRecurringIntervalDay: 'day',
    PriceRecurringIntervalMonth: 'month',
    PriceRecurringIntervalWeek: 'week',
    PriceRecurringIntervalYear: 'year'
} as const;

export type StripePriceRecurringInterval = typeof StripePriceRecurringInterval[keyof typeof StripePriceRecurringInterval];


/**
 * 
 * @export
 * @enum {string}
 */

export const StripePriceRecurringUsageType = {
    PriceRecurringUsageTypeLicensed: 'licensed',
    PriceRecurringUsageTypeMetered: 'metered'
} as const;

export type StripePriceRecurringUsageType = typeof StripePriceRecurringUsageType[keyof typeof StripePriceRecurringUsageType];


/**
 * 
 * @export
 * @enum {string}
 */

export const StripePriceTaxBehavior = {
    PriceTaxBehaviorExclusive: 'exclusive',
    PriceTaxBehaviorInclusive: 'inclusive',
    PriceTaxBehaviorUnspecified: 'unspecified'
} as const;

export type StripePriceTaxBehavior = typeof StripePriceTaxBehavior[keyof typeof StripePriceTaxBehavior];


/**
 * 
 * @export
 * @interface StripePriceTier
 */
export interface StripePriceTier {
    /**
     * Price for the entire tier.
     * @type {number}
     * @memberof StripePriceTier
     */
    'flat_amount'?: number;
    /**
     * Same as `flat_amount`, but contains a decimal value with at most 12 decimal places.
     * @type {string}
     * @memberof StripePriceTier
     */
    'flat_amount_decimal'?: string;
    /**
     * Per unit price for units relevant to the tier.
     * @type {number}
     * @memberof StripePriceTier
     */
    'unit_amount'?: number;
    /**
     * Same as `unit_amount`, but contains a decimal value with at most 12 decimal places.
     * @type {string}
     * @memberof StripePriceTier
     */
    'unit_amount_decimal'?: string;
    /**
     * Up to and including to this quantity will be contained in the tier.
     * @type {number}
     * @memberof StripePriceTier
     */
    'up_to'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const StripePriceTiersMode = {
    PriceTiersModeGraduated: 'graduated',
    PriceTiersModeVolume: 'volume'
} as const;

export type StripePriceTiersMode = typeof StripePriceTiersMode[keyof typeof StripePriceTiersMode];


/**
 * Apply a transformation to the reported usage or set quantity before computing the amount billed. Cannot be combined with `tiers`.
 * @export
 * @interface StripePriceTransformQuantity
 */
export interface StripePriceTransformQuantity {
    /**
     * Divide usage by this number.
     * @type {number}
     * @memberof StripePriceTransformQuantity
     */
    'divide_by'?: number;
    /**
     * After division, either round the result `up` or `down`.
     * @type {StripePriceTransformQuantityRound}
     * @memberof StripePriceTransformQuantity
     */
    'round'?: StripePriceTransformQuantityRound;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const StripePriceTransformQuantityRound = {
    PriceTransformQuantityRoundDown: 'down',
    PriceTransformQuantityRoundUp: 'up'
} as const;

export type StripePriceTransformQuantityRound = typeof StripePriceTransformQuantityRound[keyof typeof StripePriceTransformQuantityRound];


/**
 * 
 * @export
 * @enum {string}
 */

export const StripePriceType = {
    PriceTypeOneTime: 'one_time',
    PriceTypeRecurring: 'recurring'
} as const;

export type StripePriceType = typeof StripePriceType[keyof typeof StripePriceType];


/**
 * 
 * @export
 * @interface StripeProduct
 */
export interface StripeProduct {
    /**
     * Whether the product is currently available for purchase.
     * @type {boolean}
     * @memberof StripeProduct
     */
    'active'?: boolean;
    /**
     * A list of up to 5 attributes that each SKU can provide values for (e.g., `[\"color\", \"size\"]`).
     * @type {Array<string>}
     * @memberof StripeProduct
     */
    'attributes'?: Array<string>;
    /**
     * A short one-line description of the product, meant to be displayable to the customer. Only applicable to products of `type=good`.
     * @type {string}
     * @memberof StripeProduct
     */
    'caption'?: string;
    /**
     * Time at which the object was created. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof StripeProduct
     */
    'created'?: number;
    /**
     * An array of connect application identifiers that cannot purchase this product. Only applicable to products of `type=good`.
     * @type {Array<string>}
     * @memberof StripeProduct
     */
    'deactivate_on'?: Array<string>;
    /**
     * 
     * @type {StripeProductDefaultPrice}
     * @memberof StripeProduct
     */
    'default_price'?: StripeProductDefaultPrice;
    /**
     * 
     * @type {boolean}
     * @memberof StripeProduct
     */
    'deleted'?: boolean;
    /**
     * The product\'s description, meant to be displayable to the customer. Use this field to optionally store a long form explanation of the product being sold for your own rendering purposes.
     * @type {string}
     * @memberof StripeProduct
     */
    'description'?: string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof StripeProduct
     */
    'id'?: string;
    /**
     * A list of up to 8 URLs of images for this product, meant to be displayable to the customer.
     * @type {Array<string>}
     * @memberof StripeProduct
     */
    'images'?: Array<string>;
    /**
     * Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
     * @type {boolean}
     * @memberof StripeProduct
     */
    'livemode'?: boolean;
    /**
     * Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
     * @type {{ [key: string]: string; }}
     * @memberof StripeProduct
     */
    'metadata'?: { [key: string]: string; };
    /**
     * The product\'s name, meant to be displayable to the customer.
     * @type {string}
     * @memberof StripeProduct
     */
    'name'?: string;
    /**
     * String representing the object\'s type. Objects of the same type share the same value.
     * @type {string}
     * @memberof StripeProduct
     */
    'object'?: string;
    /**
     * 
     * @type {StripeProductPackageDimensions}
     * @memberof StripeProduct
     */
    'package_dimensions'?: StripeProductPackageDimensions;
    /**
     * Whether this product is shipped (i.e., physical goods).
     * @type {boolean}
     * @memberof StripeProduct
     */
    'shippable'?: boolean;
    /**
     * Extra information about a product which will appear on your customer\'s credit card statement. In the case that multiple products are billed at once, the first statement descriptor will be used.
     * @type {string}
     * @memberof StripeProduct
     */
    'statement_descriptor'?: string;
    /**
     * 
     * @type {StripeProductTaxCode}
     * @memberof StripeProduct
     */
    'tax_code'?: StripeProductTaxCode;
    /**
     * The type of the product. The product is either of type `good`, which is eligible for use with Orders and SKUs, or `service`, which is eligible for use with Subscriptions and Plans.
     * @type {StripeProductType}
     * @memberof StripeProduct
     */
    'type'?: StripeProductType;
    /**
     * A label that represents units of this product. When set, this will be included in customers\' receipts, invoices, Checkout, and the customer portal.
     * @type {string}
     * @memberof StripeProduct
     */
    'unit_label'?: string;
    /**
     * Time at which the object was last updated. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof StripeProduct
     */
    'updated'?: number;
    /**
     * A URL of a publicly-accessible webpage for this product.
     * @type {string}
     * @memberof StripeProduct
     */
    'url'?: string;
}
/**
 * The ID of the [Price](https://stripe.com/docs/api/prices) object that is the default price for this product.
 * @export
 * @interface StripeProductDefaultPrice
 */
export interface StripeProductDefaultPrice {
    /**
     * Whether the price can be used for new purchases.
     * @type {boolean}
     * @memberof StripeProductDefaultPrice
     */
    'active'?: boolean;
    /**
     * Describes how to compute the price per period. Either `per_unit` or `tiered`. `per_unit` indicates that the fixed amount (specified in `unit_amount` or `unit_amount_decimal`) will be charged per unit in `quantity` (for prices with `usage_type=licensed`), or per unit of total usage (for prices with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as defined using the `tiers` and `tiers_mode` attributes.
     * @type {StripePriceBillingScheme}
     * @memberof StripeProductDefaultPrice
     */
    'billing_scheme'?: StripePriceBillingScheme;
    /**
     * Time at which the object was created. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof StripeProductDefaultPrice
     */
    'created'?: number;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @type {StripeCurrency}
     * @memberof StripeProductDefaultPrice
     */
    'currency'?: StripeCurrency;
    /**
     * Prices defined in each available currency option. Each key must be a three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html) and a [supported currency](https://stripe.com/docs/currencies).
     * @type {{ [key: string]: StripePriceCurrencyOptions; }}
     * @memberof StripeProductDefaultPrice
     */
    'currency_options'?: { [key: string]: StripePriceCurrencyOptions; };
    /**
     * 
     * @type {StripePriceCustomUnitAmount}
     * @memberof StripeProductDefaultPrice
     */
    'custom_unit_amount'?: StripePriceCustomUnitAmount;
    /**
     * 
     * @type {boolean}
     * @memberof StripeProductDefaultPrice
     */
    'deleted'?: boolean;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof StripeProductDefaultPrice
     */
    'id'?: string;
    /**
     * Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
     * @type {boolean}
     * @memberof StripeProductDefaultPrice
     */
    'livemode'?: boolean;
    /**
     * A lookup key used to retrieve prices dynamically from a static string. This may be up to 200 characters.
     * @type {string}
     * @memberof StripeProductDefaultPrice
     */
    'lookup_key'?: string;
    /**
     * Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
     * @type {{ [key: string]: string; }}
     * @memberof StripeProductDefaultPrice
     */
    'metadata'?: { [key: string]: string; };
    /**
     * A brief description of the price, hidden from customers.
     * @type {string}
     * @memberof StripeProductDefaultPrice
     */
    'nickname'?: string;
    /**
     * String representing the object\'s type. Objects of the same type share the same value.
     * @type {string}
     * @memberof StripeProductDefaultPrice
     */
    'object'?: string;
    /**
     * 
     * @type {StripePriceProduct}
     * @memberof StripeProductDefaultPrice
     */
    'product'?: StripePriceProduct;
    /**
     * 
     * @type {StripePriceRecurring}
     * @memberof StripeProductDefaultPrice
     */
    'recurring'?: StripePriceRecurring;
    /**
     * Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it cannot be changed.
     * @type {StripePriceTaxBehavior}
     * @memberof StripeProductDefaultPrice
     */
    'tax_behavior'?: StripePriceTaxBehavior;
    /**
     * Each element represents a pricing tier. This parameter requires `billing_scheme` to be set to `tiered`. See also the documentation for `billing_scheme`.
     * @type {Array<StripePriceTier>}
     * @memberof StripeProductDefaultPrice
     */
    'tiers'?: Array<StripePriceTier>;
    /**
     * Defines if the tiering price should be `graduated` or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per unit price. In `graduated` tiering, pricing can change as the quantity grows.
     * @type {StripePriceTiersMode}
     * @memberof StripeProductDefaultPrice
     */
    'tiers_mode'?: StripePriceTiersMode;
    /**
     * 
     * @type {StripePriceTransformQuantity}
     * @memberof StripeProductDefaultPrice
     */
    'transform_quantity'?: StripePriceTransformQuantity;
    /**
     * One of `one_time` or `recurring` depending on whether the price is for a one-time purchase or a recurring (subscription) purchase.
     * @type {StripePriceType}
     * @memberof StripeProductDefaultPrice
     */
    'type'?: StripePriceType;
    /**
     * The unit amount in %s to be charged, represented as a whole integer if possible. Only set if `billing_scheme=per_unit`.
     * @type {number}
     * @memberof StripeProductDefaultPrice
     */
    'unit_amount'?: number;
    /**
     * The unit amount in %s to be charged, represented as a decimal string with at most 12 decimal places. Only set if `billing_scheme=per_unit`.
     * @type {string}
     * @memberof StripeProductDefaultPrice
     */
    'unit_amount_decimal'?: string;
}
/**
 * The dimensions of this product for shipping purposes.
 * @export
 * @interface StripeProductPackageDimensions
 */
export interface StripeProductPackageDimensions {
    /**
     * Height, in inches.
     * @type {number}
     * @memberof StripeProductPackageDimensions
     */
    'height'?: number;
    /**
     * Length, in inches.
     * @type {number}
     * @memberof StripeProductPackageDimensions
     */
    'length'?: number;
    /**
     * Weight, in ounces.
     * @type {number}
     * @memberof StripeProductPackageDimensions
     */
    'weight'?: number;
    /**
     * Width, in inches.
     * @type {number}
     * @memberof StripeProductPackageDimensions
     */
    'width'?: number;
}
/**
 * A [tax code](https://stripe.com/docs/tax/tax-categories) ID.
 * @export
 * @interface StripeProductTaxCode
 */
export interface StripeProductTaxCode {
    /**
     * A detailed description of which types of products the tax code represents.
     * @type {string}
     * @memberof StripeProductTaxCode
     */
    'description'?: string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof StripeProductTaxCode
     */
    'id'?: string;
    /**
     * A short name for the tax code.
     * @type {string}
     * @memberof StripeProductTaxCode
     */
    'name'?: string;
    /**
     * String representing the object\'s type. Objects of the same type share the same value.
     * @type {string}
     * @memberof StripeProductTaxCode
     */
    'object'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const StripeProductType = {
    ProductTypeGood: 'good',
    ProductTypeService: 'service'
} as const;

export type StripeProductType = typeof StripeProductType[keyof typeof StripeProductType];


/**
 * 
 * @export
 * @interface StripeTaxCode
 */
export interface StripeTaxCode {
    /**
     * A detailed description of which types of products the tax code represents.
     * @type {string}
     * @memberof StripeTaxCode
     */
    'description'?: string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof StripeTaxCode
     */
    'id'?: string;
    /**
     * A short name for the tax code.
     * @type {string}
     * @memberof StripeTaxCode
     */
    'name'?: string;
    /**
     * String representing the object\'s type. Objects of the same type share the same value.
     * @type {string}
     * @memberof StripeTaxCode
     */
    'object'?: string;
}

/**
 * PaymentApi - axios parameter creator
 * @export
 */
export const PaymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a payment without customer
         * @param {MainPaymentRequest} request PaymentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payPost: async (request: MainPaymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('payPost', 'request', request)
            const localVarPath = `/pay`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pay a Subscription
         * @param {MainPaymentRequest} request PaymentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paySubscriptionPost: async (request: MainPaymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('paySubscriptionPost', 'request', request)
            const localVarPath = `/pay-subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a payment with customer
         * @param {MainPaymentRequestWithCustomer} request PaymentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payWithCustomerPost: async (request: MainPaymentRequestWithCustomer, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('payWithCustomerPost', 'request', request)
            const localVarPath = `/pay-with-customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentApi - functional programming interface
 * @export
 */
export const PaymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a payment without customer
         * @param {MainPaymentRequest} request PaymentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payPost(request: MainPaymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainSuccessPayment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Pay a Subscription
         * @param {MainPaymentRequest} request PaymentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paySubscriptionPost(request: MainPaymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainSuccessPayment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paySubscriptionPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a payment with customer
         * @param {MainPaymentRequestWithCustomer} request PaymentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payWithCustomerPost(request: MainPaymentRequestWithCustomer, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainSuccessPayment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payWithCustomerPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentApi - factory interface
 * @export
 */
export const PaymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentApiFp(configuration)
    return {
        /**
         * Create a payment without customer
         * @param {MainPaymentRequest} request PaymentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payPost(request: MainPaymentRequest, options?: any): AxiosPromise<MainSuccessPayment> {
            return localVarFp.payPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Pay a Subscription
         * @param {MainPaymentRequest} request PaymentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paySubscriptionPost(request: MainPaymentRequest, options?: any): AxiosPromise<MainSuccessPayment> {
            return localVarFp.paySubscriptionPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a payment with customer
         * @param {MainPaymentRequestWithCustomer} request PaymentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payWithCustomerPost(request: MainPaymentRequestWithCustomer, options?: any): AxiosPromise<MainSuccessPayment> {
            return localVarFp.payWithCustomerPost(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
export class PaymentApi extends BaseAPI {
    /**
     * Create a payment without customer
     * @param {MainPaymentRequest} request PaymentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public payPost(request: MainPaymentRequest, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).payPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pay a Subscription
     * @param {MainPaymentRequest} request PaymentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paySubscriptionPost(request: MainPaymentRequest, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).paySubscriptionPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a payment with customer
     * @param {MainPaymentRequestWithCustomer} request PaymentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public payWithCustomerPost(request: MainPaymentRequestWithCustomer, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).payWithCustomerPost(request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Subscription
         * @param {MainPaymentRequest} request PaymentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionPost: async (request: MainPaymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createSubscriptionPost', 'request', request)
            const localVarPath = `/create-subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a Subscription
         * @param {MainPaymentRequest} request PaymentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscriptionPost(request: MainPaymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainSuccessPayment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscriptionPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * Create a Subscription
         * @param {MainPaymentRequest} request PaymentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionPost(request: MainPaymentRequest, options?: any): AxiosPromise<MainSuccessPayment> {
            return localVarFp.createSubscriptionPost(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * Create a Subscription
     * @param {MainPaymentRequest} request PaymentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public createSubscriptionPost(request: MainPaymentRequest, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).createSubscriptionPost(request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * List all products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StripeProduct>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * List all products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet(options?: any): AxiosPromise<Array<StripeProduct>> {
            return localVarFp.productsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * List all products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsGet(options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsGet(options).then((request) => request(this.axios, this.basePath));
    }
}


